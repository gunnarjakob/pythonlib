<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>gvpy.plot API documentation</title>
<meta name="description" content="Anything plotting related (mostly matplotlib) lives here." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gvpy.plot</code></h1>
</header>
<section id="section-intro">
<p>Anything plotting related (mostly matplotlib) lives here.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
&#34;&#34;&#34;Anything plotting related (mostly matplotlib) lives here.&#34;&#34;&#34;

from pathlib import Path

import matplotlib as mpl
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
import numpy as np
from cycler import cycler
from matplotlib.collections import LineCollection
from matplotlib.colors import LinearSegmentedColormap

from IPython import get_ipython

ipython = get_ipython()

# import cm to register colormaps defined therein
from . import cm

try:
    import cartopy.crs as ccrs
    from cartopy.mpl.gridliner import LATITUDE_FORMATTER, LONGITUDE_FORMATTER
except ImportError:
    _has_cartopy = False
else:
    _has_cartopy = True


def nostalgic():
    &#34;&#34;&#34;
    Reading old papers and feeling nostalgic? Fear not! This will change the
    default matplotlib settings to transport you right back several decades.
    &#34;&#34;&#34;
    mpl.rcParams[&#34;font.size&#34;] = 11
    mpl.rcParams[&#34;font.family&#34;] = &#34;Routed Gothic&#34;
    mpl.rcParams[&#34;mathtext.fontset&#34;] = &#34;custom&#34;
    mpl.rcParams[&#34;mathtext.rm&#34;] = &#34;Routed Gothic&#34;
    mpl.rcParams[&#34;mathtext.it&#34;] = &#34;Routed Gothic:italic&#34;
    mpl.rcParams[&#34;mathtext.bf&#34;] = &#34;Routed Gothic:bold&#34;
    mpl.rcParams[&#34;axes.titlesize&#34;] = &#34;x-large&#34;


def stix():
    &#34;&#34;&#34;
    Use STIX fonts
    &#34;&#34;&#34;
    mpl.rcParams[&#34;font.size&#34;] = 11
    mpl.rcParams[&#34;font.family&#34;] = &#34;STIX Two Text&#34;
    mpl.rcParams[&#34;mathtext.fontset&#34;] = &#34;custom&#34;
    mpl.rcParams[&#34;mathtext.rm&#34;] = &#34;STIX Two Math&#34;
    mpl.rcParams[&#34;mathtext.it&#34;] = &#34;STIX Two Math:italic&#34;
    mpl.rcParams[&#34;mathtext.bf&#34;] = &#34;STIX Two Math:bold&#34;
    mpl.rcParams[&#34;axes.titlesize&#34;] = &#34;large&#34;


def back2future():
    &#34;&#34;&#34;
    Activate matplotlib settings from the default matplotlibrc file.
    &#34;&#34;&#34;
    print(&#34;Activating settings from&#34;, mpl.matplotlib_fname())
    mpl.rc_file_defaults()
    mpl.rcParams[&#34;axes.titlesize&#34;] = &#34;medium&#34;


def switch_backend():
    &#34;&#34;&#34;
    Use to switch between regular inline and ipympl backend.
    &#34;&#34;&#34;
    backend_list = [
        &#34;module://ipykernel.pylab.backend_inline&#34;,
        &#34;module://ipympl.backend_nbagg&#34;,
    ]
    current_backend = mpl.get_backend()
    if current_backend == backend_list[0]:
        ipython.magic(&#34;matplotlib ipympl&#34;)
        print(&#34;switched to ipympl plots&#34;)
    else:
        ipython.magic(&#34;matplotlib inline&#34;)
        print(&#34;switched to inline plots&#34;)


def quickfig(fs=10, yi=True, w=6, h=4, fgs=None):
    &#34;&#34;&#34;
    Quick single pane figure.
    
    Automatically sets yaxis to be decreasing upwards so 
    we can plot against depth.
    
    Also closes all other figures for convenience.

    Parameters
    ----------
    fs : int, optional
        Fontsize (default 10)
    yi : bool, optional
        Increasing yaxis (default False)
    w : float, optional
        Figure width in inches (default 6)
    h : float, optional
        Figure height in inches (default 4)
    fgs : (float, float)
        Figure size, constructed as (w, h) if not specified here.

    Returns
    -------
    fig : matplotlib.figure.Figure
        Figure handle
    ax : matplotlib.axes._subplots.AxesSubplot
        Axis handle
    &#34;&#34;&#34;
    if fgs is None:
        fgs = (w, h)

    fig, ax = plt.subplots(
        nrows=1, ncols=1, figsize=fgs, constrained_layout=True, dpi=75
    )
    axstyle(ax, fontsize=fs)
    if yi is False:
        ax.invert_yaxis()
    ax.autoscale()

    # some adjustments when using ipympl
    current_backend = mpl.get_backend()
    if current_backend == &#34;module://ipympl.backend_nbagg&#34;:
        fig.canvas.header_visible = False
        fig.canvas.toolbar_position = &#34;bottom&#34;
        fig.canvas.resizable = False

    return fig, ax


def newfig(width=7.5, height=5.5, fontsize=12):
    &#34;&#34;&#34;
    Create new figure with own style.

    Parameters
    ----------
    width : float (optional)
        Figure width in inch
    height : float (optional)
        Figure height in inch
    fontsize : int (optional)
        Fontsize for tick labels, axis labels

    Returns
    -------
    fig : Figure handle
    ax : Axis handle
    &#34;&#34;&#34;

    fig = plt.figure(figsize=(width, height))
    ax = plt.subplot(111)

    # Get rid of ticks. The position of the numbers is informative enough of
    # the position of the value.
    ax.xaxis.set_ticks_position(&#34;none&#34;)
    ax.yaxis.set_ticks_position(&#34;none&#34;)

    # Remove top and right axes lines (&#34;spines&#34;)
    spines_to_remove = [&#34;top&#34;, &#34;right&#34;]
    for spine in spines_to_remove:
        ax.spines[spine].set_visible(False)

    # For remaining spines, thin out their line and change
    # the black to a slightly off-black dark grey
    almost_black = &#34;#262626&#34;
    spines_to_keep = [&#34;bottom&#34;, &#34;left&#34;]
    for spine in spines_to_keep:
        ax.spines[spine].set_linewidth(0.5)
        ax.spines[spine].set_color(almost_black)
        ax.spines[spine].set_position((&#34;outward&#34;, 5))

    # Change the labels to the off-black and adjust fontsize etc.
    ax.tick_params(
        axis=&#34;both&#34;,
        which=&#34;major&#34;,
        labelsize=fontsize,
        length=0,
        colors=almost_black,
        direction=&#34;in&#34;,
    )
    ax.yaxis.label.set_size(fontsize)
    ax.xaxis.label.set_size(fontsize)

    # Change the axis title to off-black
    ax.title.set_color(almost_black)

    # turn grid on
    ax.grid(
        b=True,
        which=&#34;major&#34;,
        axis=&#34;both&#34;,
        color=&#34;0.7&#34;,
        linewidth=0.75,
        linestyle=&#34;-&#34;,
        alpha=0.8,
    )

    # Change figure position on screen
    # plt.get_current_fig_manager().window.setGeometry(0,0,width,height)

    return fig, ax


def axstyle(ax=None, fontsize=12, nospine=False, grid=True, ticks=&#34;off&#34;):
    &#34;&#34;&#34;
    Apply own style to axis.

    Parameters
    ----------
    ax : AxesSubplot (optional)
        Current axis will be chosen if no axis provided

    Returns
    -------
    ax : AxesSubplot
        Axis handle
    &#34;&#34;&#34;

    if ax is None:
        ax = plt.gca()

    # Remove top and right axes lines (&#34;spines&#34;)
    spines_to_remove = [&#34;top&#34;, &#34;right&#34;]
    for spine in spines_to_remove:
        ax.spines[spine].set_visible(False)

    # Remove bottom and left spines as well if desired
    if nospine:
        more_spines_to_remove = [&#34;bottom&#34;, &#34;left&#34;]
        for spine in more_spines_to_remove:
            ax.spines[spine].set_visible(False)

    if ticks == &#34;off&#34;:
        # Get rid of ticks.
        ax.xaxis.set_ticks_position(&#34;none&#34;)
        ax.yaxis.set_ticks_position(&#34;none&#34;)
    elif ticks == &#34;in&#34;:
        ax.tick_params(axis=&#34;both&#34;, direction=&#34;in&#34;, length=2)

    # For remaining spines, thin out their line and change
    # the black to a slightly off-black dark grey
    almost_black = &#34;#262626&#34;
    spines_to_keep = [&#34;bottom&#34;, &#34;left&#34;]
    for spine in spines_to_keep:
        ax.spines[spine].set_linewidth(0.5)
        ax.spines[spine].set_color(almost_black)
        ax.spines[spine].set_position((&#34;outward&#34;, 5))

    # Change the labels to the off-black
    ax.xaxis.label.set_color(almost_black)
    ax.yaxis.label.set_color(almost_black)
    ax.yaxis.label.set_size(fontsize)
    ax.yaxis.offsetText.set_fontsize(fontsize)
    ax.xaxis.label.set_size(fontsize)
    ax.xaxis.offsetText.set_fontsize(fontsize)

    # Change the labels to the off-black
    ax.tick_params(
        axis=&#34;both&#34;, which=&#34;major&#34;, labelsize=fontsize, colors=almost_black,
    )

    # Change the axis title to off-black
    ax.title.set_color(almost_black)
    ax.title.set_size(fontsize + 1)

    # turn grid on
    if grid:
        ax.grid(
            b=True,
            which=&#34;major&#34;,
            axis=&#34;both&#34;,
            color=&#34;0.5&#34;,
            linewidth=0.25,
            linestyle=&#34;-&#34;,
            alpha=0.8,
        )

    # change legend fontsize (if there is one)
    try:
        plt.setp(ax.get_legend().get_texts(), fontsize=fontsize)
    except AttributeError:
        noleg = 1

    return ax


def newfigyy(width=7.5, height=5.5, fontsize=12):
    &#34;&#34;&#34;Create figure with own style. Two y-axes.

    Set up figure with floating axes by defining `width` and `height`.
    Based on newfig.

    Parameters
    ----------
    width : float (optional)
        Figure width in inch
    height : float (optional)
        Figure height in inch
    fontsize : float (optional)
        Fontsize for tick labels, axis labels

    Returns
    -------
    fig : Figure handle
    ax1, ax2 : Axis handles

    &#34;&#34;&#34;

    fig, ax1 = newfig(width, height)
    ax2 = ax1.twinx()
    ax1 = axstyle(ax1)
    spines_to_remove = [&#34;top&#34;, &#34;left&#34;, &#34;bottom&#34;]
    for spine in spines_to_remove:
        ax2.spines[spine].set_visible(False)
    ax2.xaxis.set_ticks_position(&#34;none&#34;)
    ax2.yaxis.set_ticks_position(&#34;none&#34;)
    almost_black = &#34;#262626&#34;
    spines_to_keep = [&#34;right&#34;]
    for spine in spines_to_keep:
        ax2.spines[spine].set_linewidth(0.5)
        ax2.spines[spine].set_color(almost_black)
        ax2.spines[spine].set_position((&#34;outward&#34;, 5))
    ax2.xaxis.label.set_color(almost_black)
    ax2.yaxis.label.set_color(almost_black)
    return fig, ax1, ax2


def vstep(x, y, ax=None, *args, **kwargs):
    &#34;&#34;&#34;
    Plot vertical steps.

    Parameters
    ----------
    x : array-like
        1-D sequence of x positions
    y : array-like
        1-D sequence of y positions. It is assumed, but not checked, that it is uniformly increasing.

    Returns
    -------
    lines : list
        List of `matplotlib.lines.Line2D` objects representing the plotted data.
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    dy = np.diff(y)
    dy1 = np.insert(dy, 0, dy[0])
    dy2 = np.append(dy, dy[-1])
    y1 = y-dy1/2
    y2 = y+dy2/2
    Y = np.vstack([y1, y2]).transpose().flatten()
    X = np.vstack([x, x]).transpose().flatten()
    lines = ax.plot(X, Y, *args, **kwargs)
    return lines


def pcm(*args, **kwargs):
    &#34;&#34;&#34;
    Wrapper for matplotlib&#39;s pcolormesh, blanking out nan&#39;s and
    thereby getting the auto-range right on arrays that include nan&#39;s.

    Parameters
    ----------
    x, y : float
        coordinates in x and y (optional)
    z : numpy array
        Data array
    Returns
    -------
    h : Plot handle

    Partly based on xarray code.

    &#34;&#34;&#34;

    if len(args) == 1:
        z = args[0]
    elif len(args) == 3:
        x, y, z = args

    # set vmin, vmax based on percentiles and determine whether this is a
    # diverging ataset or not
    calc_data = np.ravel(z)
    calc_data = calc_data[np.isfinite(calc_data)]
    vmin = np.percentile(calc_data, 2.0)
    vmax = np.percentile(calc_data, 100.0 - 2.0)
    if (vmin &lt; 0) and (vmax &gt; 0):
        diverging = True
        center = 0
        vlim = max(abs(vmin - center), abs(vmax - center))
        vmin, vmax = -vlim, vlim
        vmin += center
        vmax += center
    else:
        diverging = False

    if &#34;cmap&#34; not in kwargs:
        if diverging:
            kwargs[&#34;cmap&#34;] = &#34;RdBu_r&#34;
        else:
            kwargs[&#34;cmap&#34;] = &#34;Spectral_r&#34;

    if len(args) == 1:
        if &#34;ax&#34; in kwargs:
            pax = kwargs[&#34;ax&#34;]
            del kwargs[&#34;ax&#34;]
            h = pax.pcolormesh(np.ma.masked_invalid(z), vmin=vmin, vmax=vmax, **kwargs)
        else:
            h = plt.pcolormesh(np.ma.masked_invalid(z), vmin=vmin, vmax=vmax, **kwargs)

    elif len(args) == 3:
        if &#34;ax&#34; in kwargs:
            pax = kwargs[&#34;ax&#34;]
            del kwargs[&#34;ax&#34;]
            h = pax.pcolormesh(
                x, y, np.ma.masked_invalid(z), vmin=vmin, vmax=vmax, **kwargs
            )
        else:
            h = plt.pcolormesh(
                x, y, np.ma.masked_invalid(z), vmin=vmin, vmax=vmax, **kwargs
            )
    else:
        print(&#34;You need to pass either 1 (z) or 3 (x,y,z) arguments.&#34;)

    return h


def png(fname, figdir=&#34;fig&#34;, dpi=300):
    &#34;&#34;&#34;
    Save figure as png.

    Parameters
    ----------
    fname : str
        Figure name without file extension.

    figdir : str or Path object
        Path to figure directory. Default ./fig/

    dpi : int
        Resolution (default 200)
    &#34;&#34;&#34;
    # get current working directory
    cwd = Path.cwd()
    # see if we already have a figure directory
    savedir = cwd.joinpath(figdir)
    if savedir.exists() and savedir.is_dir():
        print(&#34;saving to {}/&#34;.format(figdir))
    else:
        print(&#34;creating figure directory at {}/&#34;.format(savedir))
        savedir.mkdir()
    fname = fname + &#34;.png&#34;
    plt.savefig(savedir.joinpath(fname), dpi=dpi, bbox_inches=&#34;tight&#34;)


def figsave(fname, dirname=&#34;fig&#34;):
    &#34;&#34;&#34;
    adapted from https://github.com/jklymak/pythonlib/jmkfigure.py
    provide filename (fname)
    &#34;&#34;&#34;
    import os

    try:
        os.mkdir(dirname)
    except:
        pass

    if dirname == &#34;fig&#34;:
        pwd = os.getcwd() + &#34;/fig/&#34;
    else:
        pwd = dirname + &#34;/&#34;
    plt.savefig(dirname + &#34;/&#34; + fname + &#34;.pdf&#34;, dpi=150, bbox_inches=&#34;tight&#34;)
    plt.savefig(dirname + &#34;/&#34; + fname + &#34;.png&#34;, dpi=200, bbox_inches=&#34;tight&#34;)

    fout = open(dirname + &#34;/&#34; + fname + &#34;.tex&#34;, &#34;w&#34;)
    str = &#34;&#34;&#34;\\begin{{figure*}}[htbp]
\\centering
\\includegraphics[width=1.0\\textwidth]{{{fname}}}
\\caption{{  \\newline \\hspace{{\\linewidth}}   {{\\footnotesize {pwd}{fname}.pdf}}}}
\\label{{fig:{fname}}}
\\end{{figure*}}&#34;&#34;&#34;.format(
        pwd=pwd, fname=fname
    )
    fout.write(str)
    fout.close()

    cmd = &#34;less &#34; + dirname + &#34;/%s.tex | pbcopy&#34; % fname
    os.system(cmd)
    print(&#34;figure printed to {}&#34;.format(pwd))


def quickbasemap(ax, lon, lat, field=None):
    &#34;&#34;&#34;
    Plot a quick map using basemap.

    Parameters
    ----------
    ax : axis object
        Handle to axis
    lon, lat : float
        Longitude / Latitude
    field : float
        Field to plot on map

    Returns
    -------
    m : basemp object
        handle to the map
    x, y : float
        lon, lat in map coordinates for plotting
    &#34;&#34;&#34;
    from mpl_toolkits.basemap import Basemap

    m = Basemap(
        llcrnrlon=np.min(lon),
        llcrnrlat=np.min(lat),
        urcrnrlon=np.max(lon),
        urcrnrlat=np.max(lat),
        resolution=&#34;l&#34;,
        area_thresh=1000.0,
        projection=&#34;gall&#34;,
        lat_0=np.max(lat) - np.min(lat),
        lon_0=np.max(lon) - np.min(lon),
        ax=ax,
    )
    lonm, latm = np.meshgrid(lon, lat)
    x, y = m(lonm, latm)
    if field is not None:
        m.contourf(x, y, field, ax=ax)
    return m, x, y


def add_cax(fig, width=0.01, pad=0.01):
    &#34;&#34;&#34;
    Add a colorbar axis to a row of axes (after last axis.) This axis can then 
    be passed on to a colorbar call.

    Parameters
    ----------
    fig : figure handle
        Handle to figure.
    width : float
        Width of colorbar (optional, defaults to 0.01)
    pad : float
        Padding between last axis and cax (optional, defaults to 0.01)

    Returns
    -------
    cax : AxesSubplot instance
    &#34;&#34;&#34;
    ax = fig.axes
    from mpl_toolkits.axes_grid1 import make_axes_locatable

    divider = make_axes_locatable(ax[-1])
    dpos = divider.get_position()
    cax = fig.add_axes([dpos[0] + dpos[2] + pad, dpos[1], width, dpos[3]])
    return cax


def ydecrease(ax=None):
    &#34;&#34;&#34;
    Set decreasing yaxis as often desired when plotting a quantity
    against pressure or depth.

    Parameters
    ----------
    ax : axis handle
        Handle to axis (optional).
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    ylims = ax.get_ylim()
    ax.set_ylim(bottom=np.amax(ylims), top=np.amin(ylims))


def ysym(ax=None):
    &#34;&#34;&#34;
    Set ylim symmetric around zero based on current axis limits

    Parameters
    ----------
    ax : axis handle
        Handle to axis (optional).
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    ylims = ax.get_ylim()
    absmax = np.max(np.abs(ylims))
    ax.set_ylim([-absmax, absmax])


def xsym(ax=None):
    &#34;&#34;&#34;
    Set xlim symmetric around zero based on current axis limits

    Parameters
    ----------
    ax : axis handle
        Handle to axis.
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    xlims = ax.get_xlim()
    absmax = np.max(np.abs(xlims))
    ax.set_xlim([-absmax, absmax])


def colcyc10(ax=None):
    &#34;&#34;&#34;
    Set automatic color cycling for ax or current axis.

    Parameters
    ----------
    ax : axis handle
        Handle to axis.
    &#34;&#34;&#34;
    from cycler import cycler

    if ax is None:
        ax = plt.gca()
    colors = [
        &#34;#1F77B4&#34;,
        &#34;#FF7F0E&#34;,
        &#34;#2CA02C&#34;,
        &#34;#D62728&#34;,
        &#34;#9467BD&#34;,
        &#34;#8C564B&#34;,
        &#34;#CFECF9&#34;,
        &#34;#7F7F7F&#34;,
        &#34;#BCBD22&#34;,
        &#34;#17BECF&#34;,
    ]
    ax.set_prop_cycle(cycler(color=colors))


def xytickdist(ax=None, x=1, y=1):
    &#34;&#34;&#34;
    Set distance between ticks for xaxis and yaxis

    Parameters
    ----------
    ax : axis handle
        Handle to axis (optional).
    x : float
        Distance between xticks (default 1).
    y : float
        Distance between yticks (default 1).
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    locx = mticker.MultipleLocator(base=x)
    ax.xaxis.set_major_locator(locx)
    locy = mticker.MultipleLocator(base=y)
    ax.yaxis.set_major_locator(locy)


def concise_date(ax=None, minticks=3, maxticks=10, show_offset=True, **kwargs):
    &#34;&#34;&#34;
    Better date ticks using matplotlib&#39;s ConciseDateFormatter.

    Parameters
    ----------
    ax : axis handle
        Handle to axis (optional).
    minticks : int
        Minimum number of ticks (optional, default 6).
    maxticks : int
        Maximum number of ticks (optional, default 10).
    show_offset : bool, optional
        Show offset string to the right (default True).
        
    Note
    ----
    Currently only works for x-axis
    
    See Also
    --------
    matplotlib.mdates.ConciseDateFormatter : For formatting options that
      can be used here.
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    locator = mdates.AutoDateLocator(minticks=minticks, maxticks=maxticks)
    formatter = mdates.ConciseDateFormatter(locator, show_offset=show_offset, **kwargs)
    ax.xaxis.set_major_locator(locator)
    ax.xaxis.set_major_formatter(formatter)


def concise_date_all():
    import matplotlib.units as munits

    converter = mdates.ConciseDateConverter()
    munits.registry[np.datetime64] = converter


def cartopy_axes(ax, maxticks=&#34;auto&#34;):
    &#34;&#34;&#34;Requires cartopy.&#34;&#34;&#34;
    if not _has_cartopy:
        raise ImportError(&#34;cartopy is required to do this.&#34;)
    gl = ax.gridlines(
        crs=ccrs.PlateCarree(),
        draw_labels=True,
        linewidth=0.5,
        color=&#34;gray&#34;,
        alpha=0.5,
        linestyle=&#34;-&#34;,
    )
    gl.xlabels_top = False
    gl.ylabels_right = False
    if maxticks == &#34;auto&#34;:
        gl.xlocator = mticker.AutoLocator()
        gl.ylocator = mticker.AutoLocator()
    else:
        gl.xlocator = mticker.MaxNLocator(maxticks)
        gl.ylocator = mticker.MaxNLocator(maxticks)
    gl.xformatter = LONGITUDE_FORMATTER
    gl.yformatter = LATITUDE_FORMATTER


def multi_line(x, y, z, ax, **kwargs):
    &#34;&#34;&#34;
    Plot multiple lines with color mapping.

    Parameters
    ----------
    x : array-like
        x-vector
    y : array-like
        Data mapped to color
    z : array-like
        Data
    ax : axis
        Axis
    Returns
    -------
    line : mpl.linecollection.LineCollection
        Lines
    &#34;&#34;&#34;
    # see also here: https://matplotlib.org/examples/pylab_examples/multicolored_line.html
    norm = plt.Normalize(y.min(), y.max())
    segments = []
    zz = []
    for i, zi in enumerate(y):
        points = np.array([x, z[i, :]]).transpose()
        segments.append(points)
        zz.append(zi)
    segments = np.array(segments)
    lc = LineCollection(segments, cmap=&#34;Greys&#34;, norm=norm)
    lc.set_array(np.array(zz))
    lc.set_linewidth(1)
    # lc.set_alpha(0.5)
    line = ax.add_collection(lc)
    ax.autoscale()
    return line


def annotate_upper_left(text, ax):
    return ax.annotate(text, (0.02, 0.9), xycoords=&#34;axes fraction&#34;)


def cmap_partial(cmap_name, min, max):
    &#34;&#34;&#34;
    Extract part of a colormap.

    Parameters
    ----------
    cmap_name : str
        Colormap name
    min : float
        Minimum in the range [0, 1]
    max : float
        Maximum in the range [0, 1]

    Returns
    -------
    cmap : matplotlib.colors.LinearSegmentedColormap
        Colormap
    &#34;&#34;&#34;
    interval = np.linspace(min, max)
    tmp = plt.cm.get_cmap(cmap_name)
    colors = tmp(interval)
    cmap = LinearSegmentedColormap.from_list(&#39;name&#39;, colors)
    return cmap</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gvpy.plot.add_cax"><code class="name flex">
<span>def <span class="ident">add_cax</span></span>(<span>fig, width=0.01, pad=0.01)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a colorbar axis to a row of axes (after last axis.) This axis can then
be passed on to a colorbar call.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>figure</code> <code>handle</code></dt>
<dd>Handle to figure.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>Width of colorbar (optional, defaults to 0.01)</dd>
<dt><strong><code>pad</code></strong> :&ensp;<code>float</code></dt>
<dd>Padding between last axis and cax (optional, defaults to 0.01)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cax</code></strong> :&ensp;<code>AxesSubplot</code> <code>instance</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_cax(fig, width=0.01, pad=0.01):
    &#34;&#34;&#34;
    Add a colorbar axis to a row of axes (after last axis.) This axis can then 
    be passed on to a colorbar call.

    Parameters
    ----------
    fig : figure handle
        Handle to figure.
    width : float
        Width of colorbar (optional, defaults to 0.01)
    pad : float
        Padding between last axis and cax (optional, defaults to 0.01)

    Returns
    -------
    cax : AxesSubplot instance
    &#34;&#34;&#34;
    ax = fig.axes
    from mpl_toolkits.axes_grid1 import make_axes_locatable

    divider = make_axes_locatable(ax[-1])
    dpos = divider.get_position()
    cax = fig.add_axes([dpos[0] + dpos[2] + pad, dpos[1], width, dpos[3]])
    return cax</code></pre>
</details>
</dd>
<dt id="gvpy.plot.annotate_upper_left"><code class="name flex">
<span>def <span class="ident">annotate_upper_left</span></span>(<span>text, ax)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annotate_upper_left(text, ax):
    return ax.annotate(text, (0.02, 0.9), xycoords=&#34;axes fraction&#34;)</code></pre>
</details>
</dd>
<dt id="gvpy.plot.axstyle"><code class="name flex">
<span>def <span class="ident">axstyle</span></span>(<span>ax=None, fontsize=12, nospine=False, grid=True, ticks='off')</span>
</code></dt>
<dd>
<section class="desc"><p>Apply own style to axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>AxesSubplot</code> (optional)</dt>
<dd>Current axis will be chosen if no axis provided</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>AxesSubplot</code></dt>
<dd>Axis handle</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def axstyle(ax=None, fontsize=12, nospine=False, grid=True, ticks=&#34;off&#34;):
    &#34;&#34;&#34;
    Apply own style to axis.

    Parameters
    ----------
    ax : AxesSubplot (optional)
        Current axis will be chosen if no axis provided

    Returns
    -------
    ax : AxesSubplot
        Axis handle
    &#34;&#34;&#34;

    if ax is None:
        ax = plt.gca()

    # Remove top and right axes lines (&#34;spines&#34;)
    spines_to_remove = [&#34;top&#34;, &#34;right&#34;]
    for spine in spines_to_remove:
        ax.spines[spine].set_visible(False)

    # Remove bottom and left spines as well if desired
    if nospine:
        more_spines_to_remove = [&#34;bottom&#34;, &#34;left&#34;]
        for spine in more_spines_to_remove:
            ax.spines[spine].set_visible(False)

    if ticks == &#34;off&#34;:
        # Get rid of ticks.
        ax.xaxis.set_ticks_position(&#34;none&#34;)
        ax.yaxis.set_ticks_position(&#34;none&#34;)
    elif ticks == &#34;in&#34;:
        ax.tick_params(axis=&#34;both&#34;, direction=&#34;in&#34;, length=2)

    # For remaining spines, thin out their line and change
    # the black to a slightly off-black dark grey
    almost_black = &#34;#262626&#34;
    spines_to_keep = [&#34;bottom&#34;, &#34;left&#34;]
    for spine in spines_to_keep:
        ax.spines[spine].set_linewidth(0.5)
        ax.spines[spine].set_color(almost_black)
        ax.spines[spine].set_position((&#34;outward&#34;, 5))

    # Change the labels to the off-black
    ax.xaxis.label.set_color(almost_black)
    ax.yaxis.label.set_color(almost_black)
    ax.yaxis.label.set_size(fontsize)
    ax.yaxis.offsetText.set_fontsize(fontsize)
    ax.xaxis.label.set_size(fontsize)
    ax.xaxis.offsetText.set_fontsize(fontsize)

    # Change the labels to the off-black
    ax.tick_params(
        axis=&#34;both&#34;, which=&#34;major&#34;, labelsize=fontsize, colors=almost_black,
    )

    # Change the axis title to off-black
    ax.title.set_color(almost_black)
    ax.title.set_size(fontsize + 1)

    # turn grid on
    if grid:
        ax.grid(
            b=True,
            which=&#34;major&#34;,
            axis=&#34;both&#34;,
            color=&#34;0.5&#34;,
            linewidth=0.25,
            linestyle=&#34;-&#34;,
            alpha=0.8,
        )

    # change legend fontsize (if there is one)
    try:
        plt.setp(ax.get_legend().get_texts(), fontsize=fontsize)
    except AttributeError:
        noleg = 1

    return ax</code></pre>
</details>
</dd>
<dt id="gvpy.plot.back2future"><code class="name flex">
<span>def <span class="ident">back2future</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Activate matplotlib settings from the default matplotlibrc file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def back2future():
    &#34;&#34;&#34;
    Activate matplotlib settings from the default matplotlibrc file.
    &#34;&#34;&#34;
    print(&#34;Activating settings from&#34;, mpl.matplotlib_fname())
    mpl.rc_file_defaults()
    mpl.rcParams[&#34;axes.titlesize&#34;] = &#34;medium&#34;</code></pre>
</details>
</dd>
<dt id="gvpy.plot.cartopy_axes"><code class="name flex">
<span>def <span class="ident">cartopy_axes</span></span>(<span>ax, maxticks='auto')</span>
</code></dt>
<dd>
<section class="desc"><p>Requires cartopy.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cartopy_axes(ax, maxticks=&#34;auto&#34;):
    &#34;&#34;&#34;Requires cartopy.&#34;&#34;&#34;
    if not _has_cartopy:
        raise ImportError(&#34;cartopy is required to do this.&#34;)
    gl = ax.gridlines(
        crs=ccrs.PlateCarree(),
        draw_labels=True,
        linewidth=0.5,
        color=&#34;gray&#34;,
        alpha=0.5,
        linestyle=&#34;-&#34;,
    )
    gl.xlabels_top = False
    gl.ylabels_right = False
    if maxticks == &#34;auto&#34;:
        gl.xlocator = mticker.AutoLocator()
        gl.ylocator = mticker.AutoLocator()
    else:
        gl.xlocator = mticker.MaxNLocator(maxticks)
        gl.ylocator = mticker.MaxNLocator(maxticks)
    gl.xformatter = LONGITUDE_FORMATTER
    gl.yformatter = LATITUDE_FORMATTER</code></pre>
</details>
</dd>
<dt id="gvpy.plot.cmap_partial"><code class="name flex">
<span>def <span class="ident">cmap_partial</span></span>(<span>cmap_name, min, max)</span>
</code></dt>
<dd>
<section class="desc"><p>Extract part of a colormap.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cmap_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Colormap name</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum in the range [0, 1]</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum in the range [0, 1]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cmap</code></strong> :&ensp;<code>matplotlib.colors.LinearSegmentedColormap</code></dt>
<dd>Colormap</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cmap_partial(cmap_name, min, max):
    &#34;&#34;&#34;
    Extract part of a colormap.

    Parameters
    ----------
    cmap_name : str
        Colormap name
    min : float
        Minimum in the range [0, 1]
    max : float
        Maximum in the range [0, 1]

    Returns
    -------
    cmap : matplotlib.colors.LinearSegmentedColormap
        Colormap
    &#34;&#34;&#34;
    interval = np.linspace(min, max)
    tmp = plt.cm.get_cmap(cmap_name)
    colors = tmp(interval)
    cmap = LinearSegmentedColormap.from_list(&#39;name&#39;, colors)
    return cmap</code></pre>
</details>
</dd>
<dt id="gvpy.plot.colcyc10"><code class="name flex">
<span>def <span class="ident">colcyc10</span></span>(<span>ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Set automatic color cycling for ax or current axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>axis</code> <code>handle</code></dt>
<dd>Handle to axis.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def colcyc10(ax=None):
    &#34;&#34;&#34;
    Set automatic color cycling for ax or current axis.

    Parameters
    ----------
    ax : axis handle
        Handle to axis.
    &#34;&#34;&#34;
    from cycler import cycler

    if ax is None:
        ax = plt.gca()
    colors = [
        &#34;#1F77B4&#34;,
        &#34;#FF7F0E&#34;,
        &#34;#2CA02C&#34;,
        &#34;#D62728&#34;,
        &#34;#9467BD&#34;,
        &#34;#8C564B&#34;,
        &#34;#CFECF9&#34;,
        &#34;#7F7F7F&#34;,
        &#34;#BCBD22&#34;,
        &#34;#17BECF&#34;,
    ]
    ax.set_prop_cycle(cycler(color=colors))</code></pre>
</details>
</dd>
<dt id="gvpy.plot.concise_date"><code class="name flex">
<span>def <span class="ident">concise_date</span></span>(<span>ax=None, minticks=3, maxticks=10, show_offset=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Better date ticks using matplotlib's ConciseDateFormatter.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>axis</code> <code>handle</code></dt>
<dd>Handle to axis (optional).</dd>
<dt><strong><code>minticks</code></strong> :&ensp;<code>int</code></dt>
<dd>Minimum number of ticks (optional, default 6).</dd>
<dt><strong><code>maxticks</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of ticks (optional, default 10).</dd>
<dt><strong><code>show_offset</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Show offset string to the right (default True).</dd>
</dl>
<h2 id="note">Note</h2>
<p>Currently only works for x-axis</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>matplotlib.mdates.ConciseDateFormatter</code></dt>
<dd>For formatting options that
<code>can be used here.</code></dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concise_date(ax=None, minticks=3, maxticks=10, show_offset=True, **kwargs):
    &#34;&#34;&#34;
    Better date ticks using matplotlib&#39;s ConciseDateFormatter.

    Parameters
    ----------
    ax : axis handle
        Handle to axis (optional).
    minticks : int
        Minimum number of ticks (optional, default 6).
    maxticks : int
        Maximum number of ticks (optional, default 10).
    show_offset : bool, optional
        Show offset string to the right (default True).
        
    Note
    ----
    Currently only works for x-axis
    
    See Also
    --------
    matplotlib.mdates.ConciseDateFormatter : For formatting options that
      can be used here.
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    locator = mdates.AutoDateLocator(minticks=minticks, maxticks=maxticks)
    formatter = mdates.ConciseDateFormatter(locator, show_offset=show_offset, **kwargs)
    ax.xaxis.set_major_locator(locator)
    ax.xaxis.set_major_formatter(formatter)</code></pre>
</details>
</dd>
<dt id="gvpy.plot.concise_date_all"><code class="name flex">
<span>def <span class="ident">concise_date_all</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concise_date_all():
    import matplotlib.units as munits

    converter = mdates.ConciseDateConverter()
    munits.registry[np.datetime64] = converter</code></pre>
</details>
</dd>
<dt id="gvpy.plot.figsave"><code class="name flex">
<span>def <span class="ident">figsave</span></span>(<span>fname, dirname='fig')</span>
</code></dt>
<dd>
<section class="desc"><p>adapted from <a href="https://github.com/jklymak/pythonlib/jmkfigure.py">https://github.com/jklymak/pythonlib/jmkfigure.py</a>
provide filename (fname)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def figsave(fname, dirname=&#34;fig&#34;):
    &#34;&#34;&#34;
    adapted from https://github.com/jklymak/pythonlib/jmkfigure.py
    provide filename (fname)
    &#34;&#34;&#34;
    import os

    try:
        os.mkdir(dirname)
    except:
        pass

    if dirname == &#34;fig&#34;:
        pwd = os.getcwd() + &#34;/fig/&#34;
    else:
        pwd = dirname + &#34;/&#34;
    plt.savefig(dirname + &#34;/&#34; + fname + &#34;.pdf&#34;, dpi=150, bbox_inches=&#34;tight&#34;)
    plt.savefig(dirname + &#34;/&#34; + fname + &#34;.png&#34;, dpi=200, bbox_inches=&#34;tight&#34;)

    fout = open(dirname + &#34;/&#34; + fname + &#34;.tex&#34;, &#34;w&#34;)
    str = &#34;&#34;&#34;\\begin{{figure*}}[htbp]
\\centering
\\includegraphics[width=1.0\\textwidth]{{{fname}}}
\\caption{{  \\newline \\hspace{{\\linewidth}}   {{\\footnotesize {pwd}{fname}.pdf}}}}
\\label{{fig:{fname}}}
\\end{{figure*}}&#34;&#34;&#34;.format(
        pwd=pwd, fname=fname
    )
    fout.write(str)
    fout.close()

    cmd = &#34;less &#34; + dirname + &#34;/%s.tex | pbcopy&#34; % fname
    os.system(cmd)
    print(&#34;figure printed to {}&#34;.format(pwd))</code></pre>
</details>
</dd>
<dt id="gvpy.plot.multi_line"><code class="name flex">
<span>def <span class="ident">multi_line</span></span>(<span>x, y, z, ax, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot multiple lines with color mapping.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>array</code>-<code>like</code></dt>
<dd>x-vector</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code>-<code>like</code></dt>
<dd>Data mapped to color</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>array</code>-<code>like</code></dt>
<dd>Data</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>axis</code></dt>
<dd>Axis</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>line</code></strong> :&ensp;<code>mpl.linecollection.LineCollection</code></dt>
<dd>Lines</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multi_line(x, y, z, ax, **kwargs):
    &#34;&#34;&#34;
    Plot multiple lines with color mapping.

    Parameters
    ----------
    x : array-like
        x-vector
    y : array-like
        Data mapped to color
    z : array-like
        Data
    ax : axis
        Axis
    Returns
    -------
    line : mpl.linecollection.LineCollection
        Lines
    &#34;&#34;&#34;
    # see also here: https://matplotlib.org/examples/pylab_examples/multicolored_line.html
    norm = plt.Normalize(y.min(), y.max())
    segments = []
    zz = []
    for i, zi in enumerate(y):
        points = np.array([x, z[i, :]]).transpose()
        segments.append(points)
        zz.append(zi)
    segments = np.array(segments)
    lc = LineCollection(segments, cmap=&#34;Greys&#34;, norm=norm)
    lc.set_array(np.array(zz))
    lc.set_linewidth(1)
    # lc.set_alpha(0.5)
    line = ax.add_collection(lc)
    ax.autoscale()
    return line</code></pre>
</details>
</dd>
<dt id="gvpy.plot.newfig"><code class="name flex">
<span>def <span class="ident">newfig</span></span>(<span>width=7.5, height=5.5, fontsize=12)</span>
</code></dt>
<dd>
<section class="desc"><p>Create new figure with own style.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code> (optional)</dt>
<dd>Figure width in inch</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code> (optional)</dt>
<dd>Figure height in inch</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>int</code> (optional)</dt>
<dd>Fontsize for tick labels, axis labels</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> <code>handle</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>Axis</code> <code>handle</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newfig(width=7.5, height=5.5, fontsize=12):
    &#34;&#34;&#34;
    Create new figure with own style.

    Parameters
    ----------
    width : float (optional)
        Figure width in inch
    height : float (optional)
        Figure height in inch
    fontsize : int (optional)
        Fontsize for tick labels, axis labels

    Returns
    -------
    fig : Figure handle
    ax : Axis handle
    &#34;&#34;&#34;

    fig = plt.figure(figsize=(width, height))
    ax = plt.subplot(111)

    # Get rid of ticks. The position of the numbers is informative enough of
    # the position of the value.
    ax.xaxis.set_ticks_position(&#34;none&#34;)
    ax.yaxis.set_ticks_position(&#34;none&#34;)

    # Remove top and right axes lines (&#34;spines&#34;)
    spines_to_remove = [&#34;top&#34;, &#34;right&#34;]
    for spine in spines_to_remove:
        ax.spines[spine].set_visible(False)

    # For remaining spines, thin out their line and change
    # the black to a slightly off-black dark grey
    almost_black = &#34;#262626&#34;
    spines_to_keep = [&#34;bottom&#34;, &#34;left&#34;]
    for spine in spines_to_keep:
        ax.spines[spine].set_linewidth(0.5)
        ax.spines[spine].set_color(almost_black)
        ax.spines[spine].set_position((&#34;outward&#34;, 5))

    # Change the labels to the off-black and adjust fontsize etc.
    ax.tick_params(
        axis=&#34;both&#34;,
        which=&#34;major&#34;,
        labelsize=fontsize,
        length=0,
        colors=almost_black,
        direction=&#34;in&#34;,
    )
    ax.yaxis.label.set_size(fontsize)
    ax.xaxis.label.set_size(fontsize)

    # Change the axis title to off-black
    ax.title.set_color(almost_black)

    # turn grid on
    ax.grid(
        b=True,
        which=&#34;major&#34;,
        axis=&#34;both&#34;,
        color=&#34;0.7&#34;,
        linewidth=0.75,
        linestyle=&#34;-&#34;,
        alpha=0.8,
    )

    # Change figure position on screen
    # plt.get_current_fig_manager().window.setGeometry(0,0,width,height)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="gvpy.plot.newfigyy"><code class="name flex">
<span>def <span class="ident">newfigyy</span></span>(<span>width=7.5, height=5.5, fontsize=12)</span>
</code></dt>
<dd>
<section class="desc"><p>Create figure with own style. Two y-axes.</p>
<p>Set up figure with floating axes by defining <code>width</code> and <code>height</code>.
Based on newfig.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code> (optional)</dt>
<dd>Figure width in inch</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code> (optional)</dt>
<dd>Figure height in inch</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code> (optional)</dt>
<dd>Fontsize for tick labels, axis labels</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> <code>handle</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ax1</code></strong>, <strong><code>ax2</code></strong> :&ensp;<code>Axis</code> <code>handles</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newfigyy(width=7.5, height=5.5, fontsize=12):
    &#34;&#34;&#34;Create figure with own style. Two y-axes.

    Set up figure with floating axes by defining `width` and `height`.
    Based on newfig.

    Parameters
    ----------
    width : float (optional)
        Figure width in inch
    height : float (optional)
        Figure height in inch
    fontsize : float (optional)
        Fontsize for tick labels, axis labels

    Returns
    -------
    fig : Figure handle
    ax1, ax2 : Axis handles

    &#34;&#34;&#34;

    fig, ax1 = newfig(width, height)
    ax2 = ax1.twinx()
    ax1 = axstyle(ax1)
    spines_to_remove = [&#34;top&#34;, &#34;left&#34;, &#34;bottom&#34;]
    for spine in spines_to_remove:
        ax2.spines[spine].set_visible(False)
    ax2.xaxis.set_ticks_position(&#34;none&#34;)
    ax2.yaxis.set_ticks_position(&#34;none&#34;)
    almost_black = &#34;#262626&#34;
    spines_to_keep = [&#34;right&#34;]
    for spine in spines_to_keep:
        ax2.spines[spine].set_linewidth(0.5)
        ax2.spines[spine].set_color(almost_black)
        ax2.spines[spine].set_position((&#34;outward&#34;, 5))
    ax2.xaxis.label.set_color(almost_black)
    ax2.yaxis.label.set_color(almost_black)
    return fig, ax1, ax2</code></pre>
</details>
</dd>
<dt id="gvpy.plot.nostalgic"><code class="name flex">
<span>def <span class="ident">nostalgic</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Reading old papers and feeling nostalgic? Fear not! This will change the
default matplotlib settings to transport you right back several decades.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nostalgic():
    &#34;&#34;&#34;
    Reading old papers and feeling nostalgic? Fear not! This will change the
    default matplotlib settings to transport you right back several decades.
    &#34;&#34;&#34;
    mpl.rcParams[&#34;font.size&#34;] = 11
    mpl.rcParams[&#34;font.family&#34;] = &#34;Routed Gothic&#34;
    mpl.rcParams[&#34;mathtext.fontset&#34;] = &#34;custom&#34;
    mpl.rcParams[&#34;mathtext.rm&#34;] = &#34;Routed Gothic&#34;
    mpl.rcParams[&#34;mathtext.it&#34;] = &#34;Routed Gothic:italic&#34;
    mpl.rcParams[&#34;mathtext.bf&#34;] = &#34;Routed Gothic:bold&#34;
    mpl.rcParams[&#34;axes.titlesize&#34;] = &#34;x-large&#34;</code></pre>
</details>
</dd>
<dt id="gvpy.plot.pcm"><code class="name flex">
<span>def <span class="ident">pcm</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper for matplotlib's pcolormesh, blanking out nan's and
thereby getting the auto-range right on arrays that include nan's.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>coordinates in x and y (optional)</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>numpy</code> <code>array</code></dt>
<dd>Data array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>h</code></strong> :&ensp;<code>Plot</code> <code>handle</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Partly based on xarray code.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pcm(*args, **kwargs):
    &#34;&#34;&#34;
    Wrapper for matplotlib&#39;s pcolormesh, blanking out nan&#39;s and
    thereby getting the auto-range right on arrays that include nan&#39;s.

    Parameters
    ----------
    x, y : float
        coordinates in x and y (optional)
    z : numpy array
        Data array
    Returns
    -------
    h : Plot handle

    Partly based on xarray code.

    &#34;&#34;&#34;

    if len(args) == 1:
        z = args[0]
    elif len(args) == 3:
        x, y, z = args

    # set vmin, vmax based on percentiles and determine whether this is a
    # diverging ataset or not
    calc_data = np.ravel(z)
    calc_data = calc_data[np.isfinite(calc_data)]
    vmin = np.percentile(calc_data, 2.0)
    vmax = np.percentile(calc_data, 100.0 - 2.0)
    if (vmin &lt; 0) and (vmax &gt; 0):
        diverging = True
        center = 0
        vlim = max(abs(vmin - center), abs(vmax - center))
        vmin, vmax = -vlim, vlim
        vmin += center
        vmax += center
    else:
        diverging = False

    if &#34;cmap&#34; not in kwargs:
        if diverging:
            kwargs[&#34;cmap&#34;] = &#34;RdBu_r&#34;
        else:
            kwargs[&#34;cmap&#34;] = &#34;Spectral_r&#34;

    if len(args) == 1:
        if &#34;ax&#34; in kwargs:
            pax = kwargs[&#34;ax&#34;]
            del kwargs[&#34;ax&#34;]
            h = pax.pcolormesh(np.ma.masked_invalid(z), vmin=vmin, vmax=vmax, **kwargs)
        else:
            h = plt.pcolormesh(np.ma.masked_invalid(z), vmin=vmin, vmax=vmax, **kwargs)

    elif len(args) == 3:
        if &#34;ax&#34; in kwargs:
            pax = kwargs[&#34;ax&#34;]
            del kwargs[&#34;ax&#34;]
            h = pax.pcolormesh(
                x, y, np.ma.masked_invalid(z), vmin=vmin, vmax=vmax, **kwargs
            )
        else:
            h = plt.pcolormesh(
                x, y, np.ma.masked_invalid(z), vmin=vmin, vmax=vmax, **kwargs
            )
    else:
        print(&#34;You need to pass either 1 (z) or 3 (x,y,z) arguments.&#34;)

    return h</code></pre>
</details>
</dd>
<dt id="gvpy.plot.png"><code class="name flex">
<span>def <span class="ident">png</span></span>(<span>fname, figdir='fig', dpi=300)</span>
</code></dt>
<dd>
<section class="desc"><p>Save figure as png.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code></dt>
<dd>Figure name without file extension.</dd>
<dt><strong><code>figdir</code></strong> :&ensp;<code>str</code> or <code>Path</code> <code>object</code></dt>
<dd>Path to figure directory. Default ./fig/</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>int</code></dt>
<dd>Resolution (default 200)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def png(fname, figdir=&#34;fig&#34;, dpi=300):
    &#34;&#34;&#34;
    Save figure as png.

    Parameters
    ----------
    fname : str
        Figure name without file extension.

    figdir : str or Path object
        Path to figure directory. Default ./fig/

    dpi : int
        Resolution (default 200)
    &#34;&#34;&#34;
    # get current working directory
    cwd = Path.cwd()
    # see if we already have a figure directory
    savedir = cwd.joinpath(figdir)
    if savedir.exists() and savedir.is_dir():
        print(&#34;saving to {}/&#34;.format(figdir))
    else:
        print(&#34;creating figure directory at {}/&#34;.format(savedir))
        savedir.mkdir()
    fname = fname + &#34;.png&#34;
    plt.savefig(savedir.joinpath(fname), dpi=dpi, bbox_inches=&#34;tight&#34;)</code></pre>
</details>
</dd>
<dt id="gvpy.plot.quickbasemap"><code class="name flex">
<span>def <span class="ident">quickbasemap</span></span>(<span>ax, lon, lat, field=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot a quick map using basemap.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>axis</code> <code>object</code></dt>
<dd>Handle to axis</dd>
<dt><strong><code>lon</code></strong>, <strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitude / Latitude</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>float</code></dt>
<dd>Field to plot on map</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>basemp</code> <code>object</code></dt>
<dd>handle to the map</dd>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>lon, lat in map coordinates for plotting</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quickbasemap(ax, lon, lat, field=None):
    &#34;&#34;&#34;
    Plot a quick map using basemap.

    Parameters
    ----------
    ax : axis object
        Handle to axis
    lon, lat : float
        Longitude / Latitude
    field : float
        Field to plot on map

    Returns
    -------
    m : basemp object
        handle to the map
    x, y : float
        lon, lat in map coordinates for plotting
    &#34;&#34;&#34;
    from mpl_toolkits.basemap import Basemap

    m = Basemap(
        llcrnrlon=np.min(lon),
        llcrnrlat=np.min(lat),
        urcrnrlon=np.max(lon),
        urcrnrlat=np.max(lat),
        resolution=&#34;l&#34;,
        area_thresh=1000.0,
        projection=&#34;gall&#34;,
        lat_0=np.max(lat) - np.min(lat),
        lon_0=np.max(lon) - np.min(lon),
        ax=ax,
    )
    lonm, latm = np.meshgrid(lon, lat)
    x, y = m(lonm, latm)
    if field is not None:
        m.contourf(x, y, field, ax=ax)
    return m, x, y</code></pre>
</details>
</dd>
<dt id="gvpy.plot.quickfig"><code class="name flex">
<span>def <span class="ident">quickfig</span></span>(<span>fs=10, yi=True, w=6, h=4, fgs=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Quick single pane figure.</p>
<p>Automatically sets yaxis to be decreasing upwards so
we can plot against depth.</p>
<p>Also closes all other figures for convenience.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fs</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Fontsize (default 10)</dd>
<dt><strong><code>yi</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Increasing yaxis (default False)</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Figure width in inches (default 6)</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Figure height in inches (default 4)</dd>
<dt><strong><code>fgs</code></strong> :&ensp;(<code>float</code>, <code>float</code>)</dt>
<dd>Figure size, constructed as (w, h) if not specified here.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib.figure.Figure</code></dt>
<dd>Figure handle</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes._subplots.AxesSubplot</code></dt>
<dd>Axis handle</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quickfig(fs=10, yi=True, w=6, h=4, fgs=None):
    &#34;&#34;&#34;
    Quick single pane figure.
    
    Automatically sets yaxis to be decreasing upwards so 
    we can plot against depth.
    
    Also closes all other figures for convenience.

    Parameters
    ----------
    fs : int, optional
        Fontsize (default 10)
    yi : bool, optional
        Increasing yaxis (default False)
    w : float, optional
        Figure width in inches (default 6)
    h : float, optional
        Figure height in inches (default 4)
    fgs : (float, float)
        Figure size, constructed as (w, h) if not specified here.

    Returns
    -------
    fig : matplotlib.figure.Figure
        Figure handle
    ax : matplotlib.axes._subplots.AxesSubplot
        Axis handle
    &#34;&#34;&#34;
    if fgs is None:
        fgs = (w, h)

    fig, ax = plt.subplots(
        nrows=1, ncols=1, figsize=fgs, constrained_layout=True, dpi=75
    )
    axstyle(ax, fontsize=fs)
    if yi is False:
        ax.invert_yaxis()
    ax.autoscale()

    # some adjustments when using ipympl
    current_backend = mpl.get_backend()
    if current_backend == &#34;module://ipympl.backend_nbagg&#34;:
        fig.canvas.header_visible = False
        fig.canvas.toolbar_position = &#34;bottom&#34;
        fig.canvas.resizable = False

    return fig, ax</code></pre>
</details>
</dd>
<dt id="gvpy.plot.stix"><code class="name flex">
<span>def <span class="ident">stix</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Use STIX fonts</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stix():
    &#34;&#34;&#34;
    Use STIX fonts
    &#34;&#34;&#34;
    mpl.rcParams[&#34;font.size&#34;] = 11
    mpl.rcParams[&#34;font.family&#34;] = &#34;STIX Two Text&#34;
    mpl.rcParams[&#34;mathtext.fontset&#34;] = &#34;custom&#34;
    mpl.rcParams[&#34;mathtext.rm&#34;] = &#34;STIX Two Math&#34;
    mpl.rcParams[&#34;mathtext.it&#34;] = &#34;STIX Two Math:italic&#34;
    mpl.rcParams[&#34;mathtext.bf&#34;] = &#34;STIX Two Math:bold&#34;
    mpl.rcParams[&#34;axes.titlesize&#34;] = &#34;large&#34;</code></pre>
</details>
</dd>
<dt id="gvpy.plot.switch_backend"><code class="name flex">
<span>def <span class="ident">switch_backend</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Use to switch between regular inline and ipympl backend.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switch_backend():
    &#34;&#34;&#34;
    Use to switch between regular inline and ipympl backend.
    &#34;&#34;&#34;
    backend_list = [
        &#34;module://ipykernel.pylab.backend_inline&#34;,
        &#34;module://ipympl.backend_nbagg&#34;,
    ]
    current_backend = mpl.get_backend()
    if current_backend == backend_list[0]:
        ipython.magic(&#34;matplotlib ipympl&#34;)
        print(&#34;switched to ipympl plots&#34;)
    else:
        ipython.magic(&#34;matplotlib inline&#34;)
        print(&#34;switched to inline plots&#34;)</code></pre>
</details>
</dd>
<dt id="gvpy.plot.vstep"><code class="name flex">
<span>def <span class="ident">vstep</span></span>(<span>x, y, ax=None, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plot vertical steps.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>array</code>-<code>like</code></dt>
<dd>1-D sequence of x positions</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code>-<code>like</code></dt>
<dd>1-D sequence of y positions. It is assumed, but not checked, that it is uniformly increasing.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>lines</code></strong> :&ensp;<code>list</code></dt>
<dd>List of <code>matplotlib.lines.Line2D</code> objects representing the plotted data.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vstep(x, y, ax=None, *args, **kwargs):
    &#34;&#34;&#34;
    Plot vertical steps.

    Parameters
    ----------
    x : array-like
        1-D sequence of x positions
    y : array-like
        1-D sequence of y positions. It is assumed, but not checked, that it is uniformly increasing.

    Returns
    -------
    lines : list
        List of `matplotlib.lines.Line2D` objects representing the plotted data.
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    dy = np.diff(y)
    dy1 = np.insert(dy, 0, dy[0])
    dy2 = np.append(dy, dy[-1])
    y1 = y-dy1/2
    y2 = y+dy2/2
    Y = np.vstack([y1, y2]).transpose().flatten()
    X = np.vstack([x, x]).transpose().flatten()
    lines = ax.plot(X, Y, *args, **kwargs)
    return lines</code></pre>
</details>
</dd>
<dt id="gvpy.plot.xsym"><code class="name flex">
<span>def <span class="ident">xsym</span></span>(<span>ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Set xlim symmetric around zero based on current axis limits</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>axis</code> <code>handle</code></dt>
<dd>Handle to axis.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xsym(ax=None):
    &#34;&#34;&#34;
    Set xlim symmetric around zero based on current axis limits

    Parameters
    ----------
    ax : axis handle
        Handle to axis.
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    xlims = ax.get_xlim()
    absmax = np.max(np.abs(xlims))
    ax.set_xlim([-absmax, absmax])</code></pre>
</details>
</dd>
<dt id="gvpy.plot.xytickdist"><code class="name flex">
<span>def <span class="ident">xytickdist</span></span>(<span>ax=None, x=1, y=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Set distance between ticks for xaxis and yaxis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>axis</code> <code>handle</code></dt>
<dd>Handle to axis (optional).</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance between xticks (default 1).</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance between yticks (default 1).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xytickdist(ax=None, x=1, y=1):
    &#34;&#34;&#34;
    Set distance between ticks for xaxis and yaxis

    Parameters
    ----------
    ax : axis handle
        Handle to axis (optional).
    x : float
        Distance between xticks (default 1).
    y : float
        Distance between yticks (default 1).
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    locx = mticker.MultipleLocator(base=x)
    ax.xaxis.set_major_locator(locx)
    locy = mticker.MultipleLocator(base=y)
    ax.yaxis.set_major_locator(locy)</code></pre>
</details>
</dd>
<dt id="gvpy.plot.ydecrease"><code class="name flex">
<span>def <span class="ident">ydecrease</span></span>(<span>ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Set decreasing yaxis as often desired when plotting a quantity
against pressure or depth.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>axis</code> <code>handle</code></dt>
<dd>Handle to axis (optional).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ydecrease(ax=None):
    &#34;&#34;&#34;
    Set decreasing yaxis as often desired when plotting a quantity
    against pressure or depth.

    Parameters
    ----------
    ax : axis handle
        Handle to axis (optional).
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    ylims = ax.get_ylim()
    ax.set_ylim(bottom=np.amax(ylims), top=np.amin(ylims))</code></pre>
</details>
</dd>
<dt id="gvpy.plot.ysym"><code class="name flex">
<span>def <span class="ident">ysym</span></span>(<span>ax=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Set ylim symmetric around zero based on current axis limits</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>axis</code> <code>handle</code></dt>
<dd>Handle to axis (optional).</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ysym(ax=None):
    &#34;&#34;&#34;
    Set ylim symmetric around zero based on current axis limits

    Parameters
    ----------
    ax : axis handle
        Handle to axis (optional).
    &#34;&#34;&#34;
    if ax is None:
        ax = plt.gca()
    ylims = ax.get_ylim()
    absmax = np.max(np.abs(ylims))
    ax.set_ylim([-absmax, absmax])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gvpy" href="index.html">gvpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="gvpy.plot.add_cax" href="#gvpy.plot.add_cax">add_cax</a></code></li>
<li><code><a title="gvpy.plot.annotate_upper_left" href="#gvpy.plot.annotate_upper_left">annotate_upper_left</a></code></li>
<li><code><a title="gvpy.plot.axstyle" href="#gvpy.plot.axstyle">axstyle</a></code></li>
<li><code><a title="gvpy.plot.back2future" href="#gvpy.plot.back2future">back2future</a></code></li>
<li><code><a title="gvpy.plot.cartopy_axes" href="#gvpy.plot.cartopy_axes">cartopy_axes</a></code></li>
<li><code><a title="gvpy.plot.cmap_partial" href="#gvpy.plot.cmap_partial">cmap_partial</a></code></li>
<li><code><a title="gvpy.plot.colcyc10" href="#gvpy.plot.colcyc10">colcyc10</a></code></li>
<li><code><a title="gvpy.plot.concise_date" href="#gvpy.plot.concise_date">concise_date</a></code></li>
<li><code><a title="gvpy.plot.concise_date_all" href="#gvpy.plot.concise_date_all">concise_date_all</a></code></li>
<li><code><a title="gvpy.plot.figsave" href="#gvpy.plot.figsave">figsave</a></code></li>
<li><code><a title="gvpy.plot.multi_line" href="#gvpy.plot.multi_line">multi_line</a></code></li>
<li><code><a title="gvpy.plot.newfig" href="#gvpy.plot.newfig">newfig</a></code></li>
<li><code><a title="gvpy.plot.newfigyy" href="#gvpy.plot.newfigyy">newfigyy</a></code></li>
<li><code><a title="gvpy.plot.nostalgic" href="#gvpy.plot.nostalgic">nostalgic</a></code></li>
<li><code><a title="gvpy.plot.pcm" href="#gvpy.plot.pcm">pcm</a></code></li>
<li><code><a title="gvpy.plot.png" href="#gvpy.plot.png">png</a></code></li>
<li><code><a title="gvpy.plot.quickbasemap" href="#gvpy.plot.quickbasemap">quickbasemap</a></code></li>
<li><code><a title="gvpy.plot.quickfig" href="#gvpy.plot.quickfig">quickfig</a></code></li>
<li><code><a title="gvpy.plot.stix" href="#gvpy.plot.stix">stix</a></code></li>
<li><code><a title="gvpy.plot.switch_backend" href="#gvpy.plot.switch_backend">switch_backend</a></code></li>
<li><code><a title="gvpy.plot.vstep" href="#gvpy.plot.vstep">vstep</a></code></li>
<li><code><a title="gvpy.plot.xsym" href="#gvpy.plot.xsym">xsym</a></code></li>
<li><code><a title="gvpy.plot.xytickdist" href="#gvpy.plot.xytickdist">xytickdist</a></code></li>
<li><code><a title="gvpy.plot.ydecrease" href="#gvpy.plot.ydecrease">ydecrease</a></code></li>
<li><code><a title="gvpy.plot.ysym" href="#gvpy.plot.ysym">ysym</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>